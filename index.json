[{"authors":["young-kim","whi-kwon"],"categories":[],"content":" Introduction  OpenCV와 python으로 Image processing을 알아봅시다. 이 글은 첫 번째 posting으로, Image processing에서 Histogram이란 무엇인지에 대하여 알아보겠습니다.  Import Libraries import os import sys import math from platform import python_version import cv2 import matplotlib import matplotlib.pyplot as plt import numpy as np print(\u0026quot;Python version : \u0026quot;, python_version()) print(\u0026quot;OpenCV version : \u0026quot;, cv2.__version__) matplotlib.rcParams['figure.figsize'] = (4.0, 4.0)  Python version : 3.6.6 OpenCV version : 3.4.3  Data load sample_image_path = '../image/' sample_image = 'lena_gray.jpg' img = cv2.imread(sample_image_path + sample_image, cv2.IMREAD_GRAYSCALE)  Data description  본 예제에서 사용할 데이터는 아래와 같습니다.  거의 대부분의 OpenCV 예제에서 볼 수 있는 Lena 입니다. 단순한 특징의 배경과 복잡한 특징의 인물이 함께 존재하여 다양한 condition을 test하기 좋은 data로 널리 알려져 있습니다.   plt.imshow(img, cmap='gray') plt.title('Lena') plt.show()    Histogram  Histogram이란, 이미지에서 특정 픽셀값의 등장 빈도를 전체 픽셀 갯수 대비 비율로 나타낸 그래프 입니다. 이미지의 전체적인 명암 분포를 한 눈에 확인할 수 있습니다. 두 가지 예제 코드를 통해 Histogram에 대해 알아보겠습니다.  def plot_histogram_npy(img): w, h = img.shape w, h = int(w), int(h) hist_cnt = np.zeros(255) hist = np.zeros(255) for j in range(h): for i in range(w): hist_cnt[img[j, i]] += 1 hist = hist_cnt / (w * h) plt.plot(hist) plt.title('Histogram of Lena, numpy', size=15)  plot_histogram_npy(img)     OpenCV등을 이용하지 않고 numpy만을 이용하여 구한 Lena의 Histogram 입니다. 이미지에서 개별 픽셀값이 몇 번씩 등장하는지 확인하고 전체 픽셀 수로 normalize하여 Histogram을 얻게 됩니다.  def plot_histogram_cv(img): w, h = img.shape hist = cv2.calcHist([img], [0], None, [256], [0, 256]) hist_norm = hist / (w * h) # normalize plt.plot(hist_norm) plt.title('Histogram of Lena, OpenCV', size=15)  plot_histogram_cv(img)     OpenCV를 이용하면 함수 호출을 통해 간단하게 Histogram을 구할 수 있습니다. numpy로 구한 Histogram과 비교해 보면, 두 결과물이 완전히 동일한 것을 알 수 있습니다. \u0026lsquo;cv2.calcHist()\u0026rsquo; 를 수행하면 픽셀값 별 등장 횟수의 그래프를 얻고, 이를 normalize하여 최종적으로 Histogram을 얻게 됩니다. \u0026lsquo;cv2.calcHist()\u0026rsquo; 의 자세한 사용법은 OpenCV 공식 tutorial page를 통해 확인할 수 있습니다. [2]  Histogram\u0026nbsp;Equalization  Histogram Equalization(히스토그램 평활화)란, pixel값 0부터 255까지의 누적치가 직선 형태가 되도록 만드는 이미지 처리 기법 입니다.  히스토그램 평활화 기법은 이미지가 전체적으로 골고루 어둡거나 골고루 밝아서 특징을 분간하기 어려울 때 자주 쓰입니다.  설명이 난해하니 코드를 통해 자세히 알아보겠습니다.  def show_stacked_histogram(img): stack_hist = np.zeros(255, dtype=np.float32) eq_hist = np.zeros(255, dtype=np.float32) w, h = img.shape hist = cv2.calcHist([img], [0], None, [256], [0, 256]) for i in range(255): stack_hist[i] = np.sum(hist[:i]) eq_hist[i] = round(stack_hist[i]) eq_hist /= (w * h) plt.plot(eq_hist) plt.title('Stacked Histogram', size=15) plt.show()  show_stacked_histogram(img)     0부터 255까지의 Histogram의 누적치 입니다. 쉽게 말하면 Histogram을 적분한 것이라고 할 수 있습니다.  e.g) eq_hist[150] = 0.675 \u0026rarr; 이미지 내에서 0부터 150까지의 pixel이 차지하는 비율 = 67.5% 당연히 항상 eq_hist[0] = 0이며, eq_hist[255] = 1.0 입니다.  전체적으로 직선에 가까운 형태지만 x좌표기준 0 근처와 255 근처는 수평인 것을 알 수 있습니다.  이 말은 Lena image에서 pixel 값 기준 0 근처와 255 근처가 존재하지 않는다는 말 입니다. 즉, 다시 말해 전체 pixel 값들에 대하여 분포가 균일하지 않다는 말 입니다.  히스토그램 평활화는 이와 같이 균일하지 않은 픽셀값의 분포를 고르게 만드는 작업입니다. \u0026mdash; 그럼 이제 히스토그램 평활화를 해보겠습니다.  equ = cv2.equalizeHist(img) show_stacked_histogram(equ)     OpenCV에 구현되어있는 cv2.equalizeHist()함수를 통해 평활화한 Lena의 Histogram입니다. 이제 Histogram 누적치가 직선 형태라는 말이 확실하게 이해 되실 것 같습니다. \u0026mdash; 마지막으로 이렇게 변화시킨 이미지가 원본 이미지와 어떻게 다른지 확인해 보겠습니다.  plt.figure(figsize=(8,8)) plt.subplot(121) plt.imshow(img, cmap='gray') plt.title('Original Lena') plt.subplot(122) plt.imshow(equ, cmap='gray') plt.title('Equalized Lena') plt.show()     전체적인 톤의 변화를 확인할 수 있는데, 밝은 부분은 더 밝아지고 어두운 부분은 더 어두워지는 모습을 볼 수 있습니다.  이는 원본 이미지가 중간 정도 밝기의 픽셀을 다수 포함하고 있었고, 상대적으로 아주 어둡거나 아주 밝은 부분은 적었기 때문입니다. 히스토그램 평활화를 통해 모든 픽셀값이 동일한 비율로 등장하게끔 수정하여 이와 같은 변화가 일어났다고 볼 수 있습니다.  히스토그램 평활화에 대한 자세한 내용은 마찬가지로 OpenCV 공식 tutorial page를 통해 확인할 수 있습니다. [3]  Conclusion  이미지 분석의 기초인 히스토그램에 대하여 알아보았습니다. 또한 이미지 처리 기법중 하나인 히스토그램 평활화를 알아보았으며, 실질적으로 히스토그램에 어떤 변화를 주는지 확인할 수 있었습니다.  Reference  [1] 오일석, 컴퓨터 비전, 2014, pp. 58-63 [2] Alexander Mordvintsev \u0026amp; Abid K., \u0026lsquo;Histograms - 1 : Find, Plot, Analyze !!!\u0026lsquo;, OpenCV-python tutorials. 2013 [Online]. Available: https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_histograms/py_histogram_begins/py_histogram_begins.html#histogram-calculation-in-opencv [Accessed: 29- Mar- 2019] [3] Alexander Mordvintsev \u0026amp; Abid K., \u0026lsquo;Histograms - 2: Histogram Equalization\u0026rsquo;, OpenCV-python tutorials. 2013 [Online]. Available: https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_histograms/py_histogram_equalization/py_histogram_equalization.html#histogram-equalization [Accessed: 29- Mar- 2019]  ","date":1556716937,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1556716937,"objectID":"5e65672a04f766afe65da92e59b7d863","permalink":"/post/histogram/","publishdate":"2019-05-01T22:22:17+09:00","relpermalink":"/post/histogram/","section":"post","summary":"Histogram using OpenCV","tags":[],"title":"Histogram","type":"post"},{"authors":["young-kim","whi-kwon"],"categories":[],"content":" Introduction  OpenCV와 Python으로 Image processing을 알아봅시다. 이 글에서는 Image thresholding을 간단히 알아보고, 어떻게 응용되는지 Blob labeling예제를 통해 확인하겠습니다.  Import Libraries import os import sys import math from platform import python_version import cv2 import matplotlib.pyplot as plt import matplotlib import numpy as np print(\u0026quot;Python version : \u0026quot;, python_version()) print(\u0026quot;OpenCV version : \u0026quot;, cv2.__version__) matplotlib.rcParams['figure.figsize'] = (4.0, 4.0)  Python version : 3.6.7 OpenCV version : 3.4.5  Data load sample_image_path = '../image/' sample_image = 'lena_gray.jpg' img = cv2.imread(sample_image_path + sample_image, cv2.IMREAD_GRAYSCALE) coin_image = 'coins.jpg' mask = np.array([[0, 1, 0],[1, 1, 1], [0, 1, 0]], dtype=np.uint8) coin_img = cv2.imread(sample_image_path + coin_image, cv2.IMREAD_GRAYSCALE) ret, coin = cv2.threshold(coin_img, 240, 255, cv2.THRESH_BINARY_INV) coin = cv2.dilate(coin, mask, iterations=1) coin = cv2.erode(coin, mask, iterations=6)  Data description  본 예제에서 사용할 데이터는 아래와 같습니다.  Lena : 지난 예제에서 사용한 Lena 입니다. Coins : Blob labeling 예제에서 사용될 이미지 입니다.  blob labeling이라는 주제에 맞게 전처리가 된 이미지 입니다. (blob labeling에서 자세하게 설명합니다.)    plt.subplot(1, 2, 1) plt.imshow(img, cmap='gray') plt.title('Lena') plt.subplot(1, 2, 2) plt.imshow(coin, cmap='gray') plt.title('Coins') plt.show()    Binarization  Binarization(이진화)이란, grayscale의 이미지를 기준에 따라 0 또는 1의 값만을 갖도록 만드는 작업입니다.  일반적으로 특정 픽셀 값을 기준으로 더 작은 값은 0으로, 더 큰 값은 1로 만듭니다. 사용 목적에 따라 결과 값을 반전시킬 때도 있는데, 추후에 코드 예시로 알아보겠습니다.  이진화 자체는 단순한 작업이나, 추후에 보다 발전된 알고리즘을 다루기 위한 기본이 됩니다.  def simple_img_binarization_npy(img, threshold): w, h = img.shape b_img = np.zeros([w, h]) b_img[img \u0026gt; threshold] = 1 return b_img  plt.figure(figsize=(8, 8)) b_img1 = simple_img_binarization_npy(img, 200) b_img2 = simple_img_binarization_npy(img, 150) b_img3 = simple_img_binarization_npy(img, 100) plt.subplot(2, 2, 1) plt.imshow(img, cmap='gray') plt.title('Gray Lena') plt.subplot(2, 2, 2) plt.imshow(b_img1, cmap='gray') plt.title('Lena over 200') plt.subplot(2, 2, 3) plt.imshow(b_img2, cmap='gray') plt.title('Lena over 150') plt.subplot(2, 2, 4) plt.imshow(b_img3, cmap='gray') plt.title('Lena over 100') plt.suptitle('Lena with different threshold value (numpy)', size=15) plt.show()     위에서 numpy를 이용했다면, 이번엔 OpenCV 내장 함수를 이용하여 image threshold를 해보겠습니다. OpenCV 함수를 이용하면 numpy로 작성하는 것 보다 편리하게 다양한 결과물을 만들어낼 수 있습니다.  cv2.threshold() 함수에 전달하는 인자를 통해 threshold 알고리즘을 다양하게 변경할 수 있습니다.   ret, thresh1 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY) ret, thresh2 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY_INV) ret, thresh3 = cv2.threshold(img, 127, 255, cv2.THRESH_TRUNC) ret, thresh4 = cv2.threshold(img, 127, 255, cv2.THRESH_TOZERO) ret, thresh5 = cv2.threshold(img, 127, 255, cv2.THRESH_TOZERO_INV) plt.figure(figsize=(8, 12)) plt.subplot(3, 2, 1) plt.imshow(thresh1, cmap='gray') plt.title('threshold lena') plt.subplot(3, 2, 2) plt.imshow(thresh2, cmap='gray') plt.title('inversed threshold lena') plt.subplot(3, 2, 3) plt.imshow(thresh3, cmap='gray') plt.title('truncated threshold lena') plt.subplot(3, 2, 4) plt.imshow(thresh4, cmap='gray') plt.title('zero threshold lena') plt.subplot(3, 2, 5) plt.imshow(thresh5, cmap='gray') plt.title('inversed zero threshold lena') plt.suptitle('Lena with different threshold algorithm(OpenCV)', size=15) plt.show()    Otsu\u0026nbsp;Algorithm  Otsu algorithm(오츄 알고리즘)은 특정 threshold값을 기준으로 영상을 둘로 나눴을때, 두 영역의 명암 분포를 가장 균일하게 할 때 결과가 가장 좋을 것이다는 가정 하에 만들어진 알고리즘입니다.  여기서 균일함 이란, 두 영역 각각의 픽셀값의 분산을 의미하며, 그 차이가 가장 적게 하는 threshold 값이 오츄 알고리즘이 찾고자 하는 값입니다.  위에 기술한 목적에 따라, 알고리즘에서는 특정 Threshold $T$를 기준으로 영상을 분할하였을 때, 양쪽 영상의 분산의 weighted sum이 가장 작게 하는 $T$값을 반복적으로 계산해가며 찾습니다.\n weight는 각 영역의 넓이로 정합니다. 어떤 연산을 어떻게 반복하는지에 대한 내용이 아래 수식에 자세히 나와있습니다. $$ \\begin{align} \u0026amp; T = argmin_{t\\subseteq {1,\\cdots,L-1}} v_{within}(t) \\\\\n\u0026amp; v_{within}(t) = w_{0}(t)v_{0}(t) + w_{1}(t)v_{1}(t) \\\\\n\\\\\n\u0026amp; w_{0}(t) = \\Sigma_{i=0}^{t} \\hat h(i),\\hspace{2cm} \u0026amp;\u0026amp; w_{1}(t) = \\Sigma_{i=t+1}^{L-1} \\hat h(i)\\\\\n\u0026amp; \\mu_{0}(t)=\\frac{1}{w_{0}(t)}\\Sigma_{i=0}^{t}i\\hat h(i) \u0026amp;\u0026amp; \\mu_{1}(t)=\\frac{1}{w_{1}(t)}\\Sigma_{i=t+1}^{L-1}i\\hat h(i)\\\\\n\u0026amp; v_{0}(t) = \\frac{1}{w_{0}(t)}\\Sigma_{i=0}^{t}i\\hat h(i)(i-\\mu_{0}(t))^2 \u0026amp;\u0026amp; v_{1}(t) = \\frac{1}{w_{1}(t)}\\Sigma_{i=t+1}^{L-1}i\\hat h(i)(i-\\mu_{1}(t))^2\\\\\n\\end{align} $$  $w_{0}(t), w_{1}(t)$는 threshold 값으로 결정된 흑색 영역과 백색 영역의 크기를 각각 나타냅니다.\n $v_{0}(t), v_{1}(t)$은 두 영역의 분산을 뜻합니다.\n 위 수식을 그대로 적용하면 시간복잡도가 $\\Theta(L^{2})$이므로 실제로 사용하기 매우 어려워집니다.\n 그러나, $\\mu$와 $v$가 영상에 대해 한번만 계산하고 나면 상수처럼 취급된다는 사실에 착안하여 다음 알고리즘이 완성되었습니다. $$ \\begin{align} \u0026amp;T = argmax_{t\\subseteq{0,1,\\cdots,L-1}}v_{between}(t)\\\\\n\u0026amp;v_{between}(t)=w_{0}(t)(1-w_{0}(t))(\\mu_{0}(t)-\\mu_{1}(t))^2\\\\\n\u0026amp;\\mu = \\Sigma_{i=0}^{L-1}i\\hat h(i)\\\\\n\\\\\n\u0026amp;\\text{초깃값}(t=0):w_{0}(0)=\\hat h(0),\\ \\mu_{0}(0)=0\\\\\n\u0026amp;\\text{순환식}(t\u0026gt;0):\\\\\n\u0026amp; \\hspace{1cm} w_{0}(t)=w_{0}(t-1)+\\hat h(t)\\\\\n\u0026amp; \\hspace{1cm} \\mu_{0}(t)=\\frac{w_{0}(t-1)\\mu_{0}(t-1)+t\\hat h(t)}{w_{0}(t)}\\\\\n\u0026amp; \\hspace{1cm} \\mu_{1}(t)=\\frac{\\mu-w_{0}(t)\\mu_{0}(t)}{1-w_{0}(t)}\\\\\n\\end{align} $$\n 위 순환식을 $t$에 대하여 수행하여 가장 큰$v_{between}$를 갖도록 하는 $t$를 최종 threshold $T$로 사용합니다.\n 이와 같은 알고리즘이 OpenCV의 threshold함수에 구현되어있으며, cv2.THRESH_OTSU 파라미터를 아래 코드와 같이 사용하면 적용이 됩니다.\n  plt.figure(figsize=(8, 4)) ret, th = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU) plt.subplot(1, 2, 1) plt.imshow(img, cmap='gray') plt.title('Gray Lena') plt.subplot(1, 2, 2) plt.imshow(th, cmap='gray') plt.title('Otsu Lena') plt.suptitle('Lena with Otsu threshold value', size=15) plt.show()    Blob\u0026nbsp;labeling  Threshold를 통해 할 수 있는 일은 그야말로 무궁무진한데, 그 중 하나로 이미지 분할(image segmentation)을 예시로 들 수 있습니다.\n 만일 threshold 등의 알고리즘을 이용하여 특정 목적에 따라 영상을 분할할 수 있다면(e.g. 사람 손 or 도로의 차선) 1로 정해진 픽셀끼리 하나의 object라고 생각할 수 있을것이고, 우리는 이 object를 묶어서 사용하고 싶게 될 것입니다.  서로 다른 object인지를 판단하기 위하여 픽셀의 연결성 [2] 을 고려한 알고리즘을 수행하고 각기 다른 label을 할당하는데, 이를 Blob labeling이라 합니다.\n Blob labeling을 하면 개별 object에 대해 각각 접근하여 우리가 하고싶은 다양한 영상처리를 개별적으로 적용할 수 있게 되니, 활용도가 아주 높은 기능입니다.\n 본 예제에서는 blob labeling에 대한 개념적인 소개와 OpenCV에 구현된 함수의 간단한 사용법을 확인하겠습니다. [3] 직관적으로 원의 형상을 띄는 위치에 하나의 blob을 의미하는 파랑색 동그라미를 생성하는 모습입니다. 잘못된 위치에 그려진 blob이 눈에 띄는데요, 이와 같은 결과를 parameter를 통해 handling하는 내용에 대해서 차후 다가올 주제인 Image Segmentation에서 확인하겠습니다.   ret, coin_img = cv2.threshold(coin, 200, 255, cv2.THRESH_BINARY_INV) params = cv2.SimpleBlobDetector_Params() params.minThreshold = 10 params.maxThreshold = 255 params.filterByArea = False params.filterByCircularity = False params.filterByConvexity = False params.filterByInertia = False detector = cv2.SimpleBlobDetector_create(params) # Blob detector 선언 keypoints = detector.detect(coin_img) # Blob labeling 수행 im_with_keypoints = \\ cv2.drawKeypoints(coin_img, keypoints, np.array([]), (0, 0, 255), cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS) # 원본 이미지에 찾은 blob 그리기 plt.figure(figsize=(15,15)) plt.imshow(im_with_keypoints) plt.title('Coin keypoint', size=15) plt.show()    Conclusion  Image thresholding의 사용법과 다양한 응용방법, threshold 값을 선택해주는 Otsu 알고리즘을 알아보았습니다. 마지막에 알아본 Blob labeling은 Image processing 분야 전반에 걸쳐 사용되는 곳이 아주 많으니 추후에 더 깊이 알아보는 시간을 갖겠습니다.  Reference  [1] 오일석, 컴퓨터 비전, 2014, pp. 67-75 [2] \u0026lsquo;Pixel connectivity\u0026rsquo;, Wikipedia. 2019 [Online]. Available: https://en.wikipedia.org/wiki/Pixel_connectivity [3] Satya Mallick., \u0026lsquo;Blob Detection Using OpenCV ( Python, C++ )\u0026rsquo;, \u0026lsquo;Learn OpenCV. 2019 [Online]. Available: https://www.learnopencv.com/blob-detection-using-opencv-python-c/  ","date":1556716937,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1556716937,"objectID":"75d1a8b06357b947ef3f8fe0505ec8b8","permalink":"/post/image-thresholding/","publishdate":"2019-05-01T22:22:17+09:00","relpermalink":"/post/image-thresholding/","section":"post","summary":"Image threshold using OpenCV","tags":[],"title":"Image Thresholding","type":"post"}]