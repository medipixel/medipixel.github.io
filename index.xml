<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Medipixel</title>
    <link>/</link>
    <description>Recent content on Medipixel</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 01 May 2019 22:22:17 +0900</lastBuildDate>
    
	    <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Histogram</title>
      <link>/post/histogram/</link>
      <pubDate>Wed, 01 May 2019 22:22:17 +0900</pubDate>
      
      <guid>/post/histogram/</guid>
      <description>

&lt;hr /&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;OpenCV와 python으로 Image processing을 알아봅시다.&lt;/li&gt;
&lt;li&gt;이 글은 첫 번째 posting으로, Image processing에서 Histogram이란 무엇인지에 대하여 알아보겠습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;import-libraries&#34;&gt;Import Libraries&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import os
import sys
import math
from platform import python_version

import cv2
import matplotlib
import matplotlib.pyplot as plt
import numpy as np


print(&amp;quot;Python version : &amp;quot;, python_version())
print(&amp;quot;OpenCV version : &amp;quot;, cv2.__version__)
matplotlib.rcParams[&#39;figure.figsize&#39;] = (4.0, 4.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Python version :  3.6.6
OpenCV version :  3.4.3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;data-load&#34;&gt;Data load&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sample_image_path = &#39;../image/&#39;
sample_image = &#39;lena_gray.jpg&#39;
img = cv2.imread(sample_image_path + sample_image, cv2.IMREAD_GRAYSCALE)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;data-description&#34;&gt;Data description&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;본 예제에서 사용할 데이터는 아래와 같습니다.

&lt;ul&gt;
&lt;li&gt;거의 대부분의 OpenCV 예제에서 볼 수 있는 Lena 입니다.&lt;/li&gt;
&lt;li&gt;단순한 특징의 배경과 복잡한 특징의 인물이 함께 존재하여 다양한 condition을 test하기 좋은 data로 널리 알려져 있습니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;plt.imshow(img, cmap=&#39;gray&#39;)
plt.title(&#39;Lena&#39;)
plt.show()
&lt;/code&gt;&lt;/pre&gt;




  

&lt;figure&gt;

&lt;img src=&#34;/img/Histogram_7_0.png&#34; /&gt;


&lt;/figure&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;histogram&#34;&gt;Histogram&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Histogram이란, 이미지에서 특정 픽셀값의 등장 빈도를 전체 픽셀 갯수 대비 비율로 나타낸 그래프 입니다.&lt;/li&gt;
&lt;li&gt;이미지의 전체적인 명암 분포를 한 눈에 확인할 수 있습니다.&lt;/li&gt;
&lt;li&gt;두 가지 예제 코드를 통해 Histogram에 대해 알아보겠습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def plot_histogram_npy(img):
    w, h = img.shape
    w, h = int(w), int(h)
    hist_cnt = np.zeros(255)
    hist = np.zeros(255)
    for j in range(h):
        for i in range(w):
            hist_cnt[img[j, i]] += 1
    hist = hist_cnt / (w * h)
    plt.plot(hist)
    plt.title(&#39;Histogram of Lena, numpy&#39;, size=15)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;plot_histogram_npy(img)
&lt;/code&gt;&lt;/pre&gt;




  

&lt;figure&gt;

&lt;img src=&#34;/img/Histogram_11_0.png&#34; /&gt;


&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;OpenCV등을 이용하지 않고 numpy만을 이용하여 구한 Lena의 Histogram 입니다.&lt;/li&gt;
&lt;li&gt;이미지에서 개별 픽셀값이 몇 번씩 등장하는지 확인하고 전체 픽셀 수로 normalize하여 Histogram을 얻게 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def plot_histogram_cv(img):
    w, h = img.shape
    hist = cv2.calcHist([img], [0], None, [256], [0, 256])
    hist_norm = hist / (w * h)  # normalize
    plt.plot(hist_norm)
    plt.title(&#39;Histogram of Lena, OpenCV&#39;, size=15)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;plot_histogram_cv(img)
&lt;/code&gt;&lt;/pre&gt;




  

&lt;figure&gt;

&lt;img src=&#34;/img/Histogram_15_0.png&#34; /&gt;


&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;OpenCV를 이용하면 함수 호출을 통해 간단하게 Histogram을 구할 수 있습니다.&lt;/li&gt;
&lt;li&gt;numpy로 구한 Histogram과 비교해 보면, 두 결과물이 완전히 동일한 것을 알 수 있습니다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&amp;lsquo;cv2.calcHist()&amp;rsquo;&lt;/em&gt; 를 수행하면 픽셀값 별 등장 횟수의 그래프를 얻고, 이를 normalize하여 최종적으로 Histogram을 얻게 됩니다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&amp;lsquo;cv2.calcHist()&amp;rsquo;&lt;/em&gt; 의 자세한 사용법은 OpenCV 공식 tutorial page를 통해 확인할 수 있습니다. &lt;a href=&#34;https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_histograms/py_histogram_begins/py_histogram_begins.html#histogram-calculation-in-opencv&#34; target=&#34;_blank&#34;&gt;[2]&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;histogram-nbsp-equalization&#34;&gt;Histogram&amp;nbsp;Equalization&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Histogram Equalization(히스토그램 평활화)란, pixel값 0부터 255까지의 누적치가 직선 형태가 되도록 만드는 이미지 처리 기법 입니다.

&lt;ul&gt;
&lt;li&gt;히스토그램 평활화 기법은 이미지가 전체적으로 골고루 어둡거나 골고루 밝아서 특징을 분간하기 어려울 때 자주 쓰입니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;설명이 난해하니 코드를 통해 자세히 알아보겠습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def show_stacked_histogram(img):
    stack_hist = np.zeros(255, dtype=np.float32)
    eq_hist = np.zeros(255, dtype=np.float32)
    w, h = img.shape
    hist = cv2.calcHist([img], [0], None, [256], [0, 256])
    for i in range(255):
        stack_hist[i] = np.sum(hist[:i])
        eq_hist[i] = round(stack_hist[i])
    eq_hist /= (w * h)

    plt.plot(eq_hist)
    plt.title(&#39;Stacked Histogram&#39;, size=15)
    plt.show()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;show_stacked_histogram(img)
&lt;/code&gt;&lt;/pre&gt;




  

&lt;figure&gt;

&lt;img src=&#34;/img/Histogram_19_0.png&#34; /&gt;


&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;0부터 255까지의 Histogram의 누적치 입니다. 쉽게 말하면 Histogram을 적분한 것이라고 할 수 있습니다.

&lt;ul&gt;
&lt;li&gt;e.g) eq_hist[150] = 0.675 &amp;rarr; 이미지 내에서 &lt;strong&gt;0부터 150까지의 pixel이 차지하는 비율 = 67.5%&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;당연히 항상 eq_hist[0] = 0이며, eq_hist[255] = 1.0 입니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;전체적으로 직선에 가까운 형태지만 x좌표기준 0 근처와 255 근처는 수평인 것을 알 수 있습니다.

&lt;ul&gt;
&lt;li&gt;이 말은 Lena image에서 pixel 값 기준 0 근처와 255 근처가 존재하지 않는다는 말 입니다.&lt;/li&gt;
&lt;li&gt;즉, 다시 말해 전체 pixel 값들에 대하여 분포가 균일하지 않다는 말 입니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;히스토그램 평활화&lt;/strong&gt;는 이와 같이 &lt;strong&gt;균일하지 않은 픽셀값의 분포를 고르게&lt;/strong&gt; 만드는 작업입니다.
&amp;mdash;&lt;/li&gt;
&lt;li&gt;그럼 이제 히스토그램 평활화를 해보겠습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;equ = cv2.equalizeHist(img)
show_stacked_histogram(equ)
&lt;/code&gt;&lt;/pre&gt;




  

&lt;figure&gt;

&lt;img src=&#34;/img/Histogram_21_0.png&#34; /&gt;


&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;OpenCV에 구현되어있는 cv2.equalizeHist()함수를 통해 평활화한 Lena의 Histogram입니다.&lt;/li&gt;
&lt;li&gt;이제 Histogram 누적치가 직선 형태라는 말이 확실하게 이해 되실 것 같습니다.
&amp;mdash;&lt;/li&gt;
&lt;li&gt;마지막으로 이렇게 변화시킨 이미지가 원본 이미지와 어떻게 다른지 확인해 보겠습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;plt.figure(figsize=(8,8))

plt.subplot(121)
plt.imshow(img, cmap=&#39;gray&#39;)
plt.title(&#39;Original Lena&#39;)

plt.subplot(122)
plt.imshow(equ, cmap=&#39;gray&#39;)
plt.title(&#39;Equalized Lena&#39;)

plt.show()
&lt;/code&gt;&lt;/pre&gt;




  

&lt;figure&gt;

&lt;img src=&#34;/img/Histogram_23_0.png&#34; /&gt;


&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;전체적인 톤의 변화를 확인할 수 있는데, 밝은 부분은 더 밝아지고 어두운 부분은 더 어두워지는 모습을 볼 수 있습니다.

&lt;ul&gt;
&lt;li&gt;이는 원본 이미지가 중간 정도 밝기의 픽셀을 다수 포함하고 있었고, 상대적으로 아주 어둡거나 아주 밝은 부분은 적었기 때문입니다.&lt;/li&gt;
&lt;li&gt;히스토그램 평활화를 통해 모든 픽셀값이 동일한 비율로 등장하게끔 수정하여 이와 같은 변화가 일어났다고 볼 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;히스토그램 평활화에 대한 자세한 내용은 마찬가지로 OpenCV 공식 tutorial page를 통해 확인할 수 있습니다. &lt;a href=&#34;https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_histograms/py_histogram_equalization/py_histogram_equalization.html#histogram-equalization&#34; target=&#34;_blank&#34;&gt;[3]&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;이미지 분석의 기초인 히스토그램에 대하여 알아보았습니다.&lt;/li&gt;
&lt;li&gt;또한 이미지 처리 기법중 하나인 히스토그램 평활화를 알아보았으며, 실질적으로 히스토그램에 어떤 변화를 주는지 확인할 수 있었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;[1] 오일석, 컴퓨터 비전, 2014, pp. 58-63&lt;/li&gt;
&lt;li&gt;[2] Alexander Mordvintsev &amp;amp; Abid K., &amp;lsquo;Histograms - 1 : Find, Plot, Analyze !!!&amp;lsquo;,  OpenCV-python tutorials. 2013 [Online]. Available: &lt;a href=&#34;https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_histograms/py_histogram_begins/py_histogram_begins.html#histogram-calculation-in-opencv&#34; target=&#34;_blank&#34;&gt;https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_histograms/py_histogram_begins/py_histogram_begins.html#histogram-calculation-in-opencv&lt;/a&gt; [Accessed: 29- Mar- 2019]&lt;/li&gt;
&lt;li&gt;[3] Alexander Mordvintsev &amp;amp; Abid K., &amp;lsquo;Histograms - 2: Histogram Equalization&amp;rsquo;,  OpenCV-python tutorials. 2013 [Online]. Available: &lt;a href=&#34;https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_histograms/py_histogram_equalization/py_histogram_equalization.html#histogram-equalization&#34; target=&#34;_blank&#34;&gt;https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_histograms/py_histogram_equalization/py_histogram_equalization.html#histogram-equalization&lt;/a&gt; [Accessed: 29- Mar- 2019]&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Image Thresholding</title>
      <link>/post/image-thresholding/</link>
      <pubDate>Wed, 01 May 2019 22:22:17 +0900</pubDate>
      
      <guid>/post/image-thresholding/</guid>
      <description>

&lt;hr /&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;OpenCV와 Python으로 Image processing을 알아봅시다.&lt;/li&gt;
&lt;li&gt;이 글에서는 Image thresholding을 간단히 알아보고, 어떻게 응용되는지 Blob labeling예제를 통해 확인하겠습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;import-libraries&#34;&gt;Import Libraries&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import os
import sys
import math
from platform import python_version

import cv2
import matplotlib.pyplot as plt
import matplotlib
import numpy as np

print(&amp;quot;Python version : &amp;quot;, python_version())
print(&amp;quot;OpenCV version : &amp;quot;, cv2.__version__)
matplotlib.rcParams[&#39;figure.figsize&#39;] = (4.0, 4.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Python version :  3.6.7
OpenCV version :  3.4.5
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;data-load&#34;&gt;Data load&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sample_image_path = &#39;../image/&#39;
sample_image = &#39;lena_gray.jpg&#39;
img = cv2.imread(sample_image_path + sample_image, cv2.IMREAD_GRAYSCALE)

coin_image = &#39;coins.jpg&#39;
mask = np.array([[0, 1, 0],[1, 1, 1], [0, 1, 0]], dtype=np.uint8)
coin_img = cv2.imread(sample_image_path + coin_image, cv2.IMREAD_GRAYSCALE)

ret, coin = cv2.threshold(coin_img, 240, 255, cv2.THRESH_BINARY_INV)
coin = cv2.dilate(coin, mask, iterations=1)
coin = cv2.erode(coin, mask, iterations=6)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;data-description&#34;&gt;Data description&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;본 예제에서 사용할 데이터는 아래와 같습니다.

&lt;ul&gt;
&lt;li&gt;Lena : 지난 예제에서 사용한 Lena 입니다.&lt;/li&gt;
&lt;li&gt;Coins : Blob labeling 예제에서 사용될 이미지 입니다.

&lt;ul&gt;
&lt;li&gt;blob labeling이라는 주제에 맞게 전처리가 된 이미지 입니다. (blob labeling에서 자세하게 설명합니다.)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;plt.subplot(1, 2, 1)
plt.imshow(img, cmap=&#39;gray&#39;)
plt.title(&#39;Lena&#39;)
plt.subplot(1, 2, 2)
plt.imshow(coin, cmap=&#39;gray&#39;)
plt.title(&#39;Coins&#39;)
plt.show()
&lt;/code&gt;&lt;/pre&gt;




  

&lt;figure&gt;

&lt;img src=&#34;/img/Image-Thresholding_7_0.png&#34; /&gt;


&lt;/figure&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;binarization&#34;&gt;Binarization&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Binarization(이진화)이란, grayscale의 이미지를 기준에 따라 0 또는 1의 값만을 갖도록 만드는 작업입니다.

&lt;ul&gt;
&lt;li&gt;일반적으로 특정 픽셀 값을 기준으로 더 작은 값은 0으로, 더 큰 값은 1로 만듭니다.&lt;/li&gt;
&lt;li&gt;사용 목적에 따라 결과 값을 반전시킬 때도 있는데, 추후에 코드 예시로 알아보겠습니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;이진화 자체는 단순한 작업이나, 추후에 보다 발전된 알고리즘을 다루기 위한 기본이 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def simple_img_binarization_npy(img, threshold):
    w, h = img.shape
    b_img = np.zeros([w, h])
    b_img[img &amp;gt; threshold] = 1
    return b_img
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;plt.figure(figsize=(8, 8))
b_img1 = simple_img_binarization_npy(img, 200)
b_img2 = simple_img_binarization_npy(img, 150)
b_img3 = simple_img_binarization_npy(img, 100)

plt.subplot(2, 2, 1)
plt.imshow(img, cmap=&#39;gray&#39;)
plt.title(&#39;Gray Lena&#39;)

plt.subplot(2, 2, 2)
plt.imshow(b_img1, cmap=&#39;gray&#39;)
plt.title(&#39;Lena over 200&#39;)

plt.subplot(2, 2, 3)
plt.imshow(b_img2, cmap=&#39;gray&#39;)
plt.title(&#39;Lena over 150&#39;)

plt.subplot(2, 2, 4)
plt.imshow(b_img3, cmap=&#39;gray&#39;)
plt.title(&#39;Lena over 100&#39;)

plt.suptitle(&#39;Lena with different threshold value (numpy)&#39;, size=15)
plt.show()
&lt;/code&gt;&lt;/pre&gt;




  

&lt;figure&gt;

&lt;img src=&#34;/img/Image-Thresholding_11_0.png&#34; /&gt;


&lt;/figure&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;위에서 numpy를 이용했다면, 이번엔 OpenCV 내장 함수를 이용하여 image threshold를 해보겠습니다.&lt;/li&gt;
&lt;li&gt;OpenCV 함수를 이용하면 numpy로 작성하는 것 보다 편리하게 다양한 결과물을 만들어낼 수 있습니다.

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cv2.threshold()&lt;/code&gt; 함수에 전달하는 인자를 통해 threshold 알고리즘을 다양하게 변경할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;ret, thresh1 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)
ret, thresh2 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY_INV)
ret, thresh3 = cv2.threshold(img, 127, 255, cv2.THRESH_TRUNC)
ret, thresh4 = cv2.threshold(img, 127, 255, cv2.THRESH_TOZERO)
ret, thresh5 = cv2.threshold(img, 127, 255, cv2.THRESH_TOZERO_INV)

plt.figure(figsize=(8, 12))
plt.subplot(3, 2, 1)
plt.imshow(thresh1, cmap=&#39;gray&#39;)
plt.title(&#39;threshold lena&#39;)

plt.subplot(3, 2, 2)
plt.imshow(thresh2, cmap=&#39;gray&#39;)
plt.title(&#39;inversed threshold lena&#39;)

plt.subplot(3, 2, 3)
plt.imshow(thresh3, cmap=&#39;gray&#39;)
plt.title(&#39;truncated threshold lena&#39;)

plt.subplot(3, 2, 4)
plt.imshow(thresh4, cmap=&#39;gray&#39;)
plt.title(&#39;zero threshold lena&#39;)

plt.subplot(3, 2, 5)
plt.imshow(thresh5, cmap=&#39;gray&#39;)
plt.title(&#39;inversed zero threshold lena&#39;)

plt.suptitle(&#39;Lena with different threshold algorithm(OpenCV)&#39;, size=15)
plt.show()
&lt;/code&gt;&lt;/pre&gt;




  

&lt;figure&gt;

&lt;img src=&#34;/img/Image-Thresholding_14_0.png&#34; /&gt;


&lt;/figure&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;otsu-nbsp-algorithm&#34;&gt;Otsu&amp;nbsp;Algorithm&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Otsu algorithm(오츄 알고리즘)은 특정 threshold값을 기준으로 영상을 둘로 나눴을때, 두 영역의 명암 분포를 가장 균일하게 할 때 결과가 가장 좋을 것이다는 가정 하에 만들어진 알고리즘입니다.

&lt;ul&gt;
&lt;li&gt;여기서 균일함 이란, 두 영역 각각의 픽셀값의 분산을 의미하며, 그 차이가 가장 적게 하는 threshold 값이 오츄 알고리즘이 찾고자 하는 값입니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;위에 기술한 목적에 따라, 알고리즘에서는 특정 Threshold $T$를 기준으로 영상을 분할하였을 때, 양쪽 영상의 분산의 weighted sum이 가장 작게 하는 $T$값을 반복적으로 계산해가며 찾습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;weight는 각 영역의 넓이로 정합니다.&lt;/li&gt;
&lt;li&gt;어떤 연산을 어떻게 반복하는지에 대한 내용이 아래 수식에 자세히 나와있습니다. &lt;br&gt;
$$
\begin{align}
&amp;amp; T = argmin_{t\subseteq {1,\cdots,L-1}} v_{within}(t)
\\&lt;br /&gt;
&amp;amp; v_{within}(t) = w_{0}(t)v_{0}(t) + w_{1}(t)v_{1}(t)
\\&lt;br /&gt;
\\&lt;br /&gt;
&amp;amp; w_{0}(t) = \Sigma_{i=0}^{t} \hat h(i),\hspace{2cm} &amp;amp;&amp;amp; w_{1}(t) = \Sigma_{i=t+1}^{L-1} \hat h(i)\\&lt;br /&gt;
&amp;amp; \mu_{0}(t)=\frac{1}{w_{0}(t)}\Sigma_{i=0}^{t}i\hat h(i) &amp;amp;&amp;amp; \mu_{1}(t)=\frac{1}{w_{1}(t)}\Sigma_{i=t+1}^{L-1}i\hat h(i)\\&lt;br /&gt;
&amp;amp; v_{0}(t) = \frac{1}{w_{0}(t)}\Sigma_{i=0}^{t}i\hat h(i)(i-\mu_{0}(t))^2 &amp;amp;&amp;amp; v_{1}(t) = \frac{1}{w_{1}(t)}\Sigma_{i=t+1}^{L-1}i\hat h(i)(i-\mu_{1}(t))^2\\&lt;br /&gt;
\end{align}
$$&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$w_{0}(t), w_{1}(t)$는 threshold 값으로 결정된 흑색 영역과 백색 영역의 크기를 각각 나타냅니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$v_{0}(t), v_{1}(t)$은 두 영역의 분산을 뜻합니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;위 수식을 그대로 적용하면 시간복잡도가 $\Theta(L^{2})$이므로 실제로 사용하기 매우 어려워집니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;그러나, $\mu$와 $v$가 영상에 대해 한번만 계산하고 나면 상수처럼 취급된다는 사실에 착안하여 다음 알고리즘이 완성되었습니다. &lt;br&gt;
$$
\begin{align}
&amp;amp;T = argmax_{t\subseteq{0,1,\cdots,L-1}}v_{between}(t)\\&lt;br /&gt;
&amp;amp;v_{between}(t)=w_{0}(t)(1-w_{0}(t))(\mu_{0}(t)-\mu_{1}(t))^2\\&lt;br /&gt;
&amp;amp;\mu = \Sigma_{i=0}^{L-1}i\hat h(i)\\&lt;br /&gt;
\\&lt;br /&gt;
&amp;amp;\text{초깃값}(t=0):w_{0}(0)=\hat h(0),\ \mu_{0}(0)=0\\&lt;br /&gt;
&amp;amp;\text{순환식}(t&amp;gt;0):\\&lt;br /&gt;
&amp;amp; \hspace{1cm} w_{0}(t)=w_{0}(t-1)+\hat h(t)\\&lt;br /&gt;
&amp;amp; \hspace{1cm} \mu_{0}(t)=\frac{w_{0}(t-1)\mu_{0}(t-1)+t\hat h(t)}{w_{0}(t)}\\&lt;br /&gt;
&amp;amp; \hspace{1cm} \mu_{1}(t)=\frac{\mu-w_{0}(t)\mu_{0}(t)}{1-w_{0}(t)}\\&lt;br /&gt;
\end{align}
$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;위 순환식을 $t$에 대하여 수행하여 가장 큰$v_{between}$를 갖도록 하는 $t$를 최종 threshold $T$로 사용합니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;이와 같은 알고리즘이 OpenCV의 threshold함수에 구현되어있으며, &lt;code&gt;cv2.THRESH_OTSU&lt;/code&gt; 파라미터를 아래 코드와 같이 사용하면 적용이 됩니다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;plt.figure(figsize=(8, 4))
ret, th = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

plt.subplot(1, 2, 1)
plt.imshow(img, cmap=&#39;gray&#39;)
plt.title(&#39;Gray Lena&#39;)

plt.subplot(1, 2, 2)
plt.imshow(th, cmap=&#39;gray&#39;)
plt.title(&#39;Otsu Lena&#39;)

plt.suptitle(&#39;Lena with Otsu threshold value&#39;, size=15)
plt.show()
&lt;/code&gt;&lt;/pre&gt;




  

&lt;figure&gt;

&lt;img src=&#34;/img/Image-Thresholding_21_0.png&#34; /&gt;


&lt;/figure&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;blob-nbsp-labeling&#34;&gt;Blob&amp;nbsp;labeling&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Threshold를 통해 할 수 있는 일은 그야말로 무궁무진한데, 그 중 하나로 이미지 분할(image segmentation)을 예시로 들 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;만일 threshold 등의 알고리즘을 이용하여 특정 목적에 따라 영상을 분할할 수 있다면(e.g. 사람 손 or 도로의 차선)
1로 정해진 픽셀끼리 하나의 object라고 생각할 수 있을것이고, 우리는 이 object를 묶어서 사용하고 싶게 될 것입니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;서로 다른 object인지를 판단하기 위하여 &lt;strong&gt;픽셀의 연결성&lt;/strong&gt; &lt;a href=&#34;https://en.wikipedia.org/wiki/Pixel_connectivity&#34; target=&#34;_blank&#34;&gt;[2]&lt;/a&gt; 을 고려한 알고리즘을 수행하고 각기 다른 label을 할당하는데, 이를 &lt;strong&gt;Blob labeling&lt;/strong&gt;이라 합니다.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Blob labeling&lt;/strong&gt;을 하면 개별 object에 대해 각각 접근하여 우리가 하고싶은 다양한 영상처리를 개별적으로 적용할 수 있게 되니, 활용도가 아주 높은 기능입니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;본 예제에서는 blob labeling에 대한 개념적인 소개와 OpenCV에 구현된 함수의 간단한 사용법을 확인하겠습니다. &lt;a href=&#34;https://www.learnopencv.com/blob-detection-using-opencv-python-c/&#34; target=&#34;_blank&#34;&gt;[3]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;직관적으로 원의 형상을 띄는 위치에 하나의 blob을 의미하는 파랑색 동그라미를 생성하는 모습입니다.&lt;/li&gt;
&lt;li&gt;잘못된 위치에 그려진 blob이 눈에 띄는데요, 이와 같은 결과를 parameter를 통해 handling하는 내용에 대해서 차후 다가올 주제인 Image Segmentation에서 확인하겠습니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;ret, coin_img = cv2.threshold(coin, 200, 255, cv2.THRESH_BINARY_INV)

params = cv2.SimpleBlobDetector_Params()
params.minThreshold = 10
params.maxThreshold = 255
params.filterByArea = False
params.filterByCircularity = False
params.filterByConvexity = False
params.filterByInertia = False

detector = cv2.SimpleBlobDetector_create(params) # Blob detector 선언
keypoints = detector.detect(coin_img)  # Blob labeling 수행
im_with_keypoints = \
cv2.drawKeypoints(coin_img, keypoints, np.array([]), (0, 0, 255),
                  cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS)  # 원본 이미지에 찾은 blob 그리기

plt.figure(figsize=(15,15))
plt.imshow(im_with_keypoints)
plt.title(&#39;Coin keypoint&#39;, size=15)
plt.show()
&lt;/code&gt;&lt;/pre&gt;




  

&lt;figure&gt;

&lt;img src=&#34;/img/Image-Thresholding_24_0.png&#34; /&gt;


&lt;/figure&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Image thresholding의 사용법과 다양한 응용방법, threshold 값을 선택해주는 Otsu 알고리즘을 알아보았습니다.&lt;/li&gt;
&lt;li&gt;마지막에 알아본 Blob labeling은 Image processing 분야 전반에 걸쳐 사용되는 곳이 아주 많으니 추후에 더 깊이 알아보는 시간을 갖겠습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;reference&#34;&gt;Reference&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;[1] 오일석, 컴퓨터 비전, 2014, pp. 67-75&lt;/li&gt;
&lt;li&gt;[2] &amp;lsquo;Pixel connectivity&amp;rsquo;, Wikipedia. 2019 [Online]. Available: &lt;a href=&#34;https://en.wikipedia.org/wiki/Pixel_connectivity&#34; target=&#34;_blank&#34;&gt;https://en.wikipedia.org/wiki/Pixel_connectivity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[3] Satya Mallick., &amp;lsquo;Blob Detection Using OpenCV ( Python, C++ )&amp;rsquo;, &amp;lsquo;Learn OpenCV. 2019 [Online]. Available: &lt;a href=&#34;https://www.learnopencv.com/blob-detection-using-opencv-python-c/&#34; target=&#34;_blank&#34;&gt;https://www.learnopencv.com/blob-detection-using-opencv-python-c/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
